# STT API

Сервис транскрибации аудио и видео на базе Parakeet v3 с опциональным разделением на спикеров. Результаты сохраняются в Postgres и доступны через API. Защина через апи токен. Есть система очередей и параллелизма.
Загрузка файлов чанками. Все работает на CPU. Скорость транскрипции 1 к 10. Скорость разделения на спикеров 1 к 2. 

## Возможности

- Сырая транскрибация (raw text)
- Тайминги слов (word-level)
- Умная сегментация для SRT
- Разделение на спикеров (опционально)
- JSON-результаты в Postgres (без файлов)
- In-process очередь задач
- API key защита
- Автоочистка старых загрузок

## Архитектура

- **FastAPI**: API и оркестрация задач
- **Parakeet v3 (onnx-asr)**: распознавание речи
- **Pyannote.audio**: diarization
- **Postgres**: хранение результатов (`public.parakeet`)
- **In-process queue**: 2 воркера, до 100 задач в очереди

## Быстрый старт (Docker)

1) Создайте `.env`:

```bash
HUGGINGFACE_TOKEN=hf_...
API_KEY=your_api_key
DATABASE_URL=postgresql://postgres:YOUR-PASSWORD@db.pbmwccssuogeopghboqb.supabase.co:5432/postgres
APP_HOST=0.0.0.0
APP_PORT=4787
```

2) Запустите сервис:

```bash
docker-compose up --build
```

3) Откройте UI:

```text
http://localhost:4787
```

## Переменные окружения

| Переменная | Обязательная | Default | Описание |
| --- | --- | --- | --- |
| `HUGGINGFACE_TOKEN` | да | - | Токен HuggingFace (нужен для diarization) |
| `API_KEY` | да | - | API ключ для всех запросов |
| `DATABASE_URL` | да | - | Postgres URL для сохранения результатов |
| `APP_HOST` | нет | `0.0.0.0` | Хост приложения |
| `APP_PORT` | нет | `4787` | Порт приложения |
| `MAX_FILE_SIZE` | нет | `524288000` | Лимит размера файла (байт) |
| `UPLOAD_CHUNK_SIZE` | нет | `10485760` | Размер чанка при загрузке |
| `UPLOAD_DIR` | нет | `./uploads` | Каталог временных загрузок |

## Авторизация

Все API запросы, кроме `/health`, `/` и `/static/*`, требуют заголовок:

```text
X-API-Key: <your_api_key>
```

UI сохраняет ключ в `localStorage` и автоматически подставляет его в запросы.

## Очередь задач

- 2 параллельные транскрибации (воркеры)
- 100 задач в очереди
- При переполнении API возвращает `429 Too Many Requests`
- Очередь in-process, сбрасывается при рестарте

## Хранение результатов

Таблица в Postgres **предварительно создана**:

```sql
create table public.parakeet (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  task_id uuid null,
  raw_text text null,
  words json null,
  srt text null,
  speaker_segments json null,
  diarization_segments json null,
  speaker_text text null,
  language text null,
  duration real null,
  processing_time real null,
  speaker_srt json null,
  constraint parakeet_pkey primary key (id)
);
```

Файловые результаты **не создаются**.

## API

### GET /health

```json
{
  "status": "healthy",
  "service": "stt-api",
  "version": "1.0.0"
}
```

### POST /transcribe

Запускает транскрибацию.

**Request** (multipart/form-data):

- `file` (required)
- `enable_diarization` (optional, default `false`)

**Response**:

```json
{
  "task_id": "uuid",
  "status": "pending",
  "message": "Transcription task started",
  "result_url": "/result/{task_id}"
}
```

**Ошибки**:

- `400` — неправильный тип файла
- `401` — неверный API ключ
- `413` — файл слишком большой
- `429` — очередь переполнена

### GET /status/{task_id}

**pending / processing**:

```json
{
  "task_id": "uuid",
  "status": "pending|processing",
  "progress": 50,
  "step": "Queued"
}
```

**completed**:

```json
{
  "task_id": "uuid",
  "status": "completed",
  "result_url": "/result/{task_id}",
  "raw_text": "transcribed text...",
  "words": [{"word": "hello", "start": 0.12, "end": 0.42}],
  "srt": "1\n00:00:00,120 --> 00:00:01,400\nhello\n",
  "speaker_srt": [{"start": 0.12, "end": 1.4, "text": "SPEAKER_00: hello"}],
  "srt_segments": [{"start": 0.12, "end": 1.4, "text": "hello"}],
  "speaker_segments": [{"start": 0.12, "end": 1.4, "speaker": "SPEAKER_00", "text": "hello"}],
  "diarization_segments": [{"start": 0.0, "end": 1.4, "speaker": "SPEAKER_00"}],
  "speaker_text": "[0.00 - 1.40] SPEAKER_00: hello",
  "language": "auto",
  "processing_time": 45.2,
  "duration": 120.5
}
```

### GET /result/{task_id}

Возвращает тот же JSON, что и `/status` при `completed`, в виде файла.

## Примеры cURL

```bash
curl -X POST http://localhost:4787/transcribe \
  -H "X-API-Key: YOUR_API_KEY" \
  -F "file=@audio.mp3" \
  -F "enable_diarization=true"

curl http://localhost:4787/status/{task_id} \
  -H "X-API-Key: YOUR_API_KEY"

curl http://localhost:4787/result/{task_id} \
  -H "X-API-Key: YOUR_API_KEY" -o result.json
```

## Автоочистка загрузок

После каждой успешной транскрибации удаляются файлы в `./uploads`, которые старше 24 часов.

## Разработка (без Docker)

1) Виртуальное окружение:

```bash
python -m venv venv
source venv/bin/activate
```

2) Установка зависимостей:

```bash
pip install -r requirements.txt
```

3) Установка FFmpeg:

```bash
sudo apt-get install ffmpeg
```

4) Запуск:

```bash
python -m app.main
```

## Структура проекта

```
stt-api/
├── app/
│   ├── config.py
│   ├── db.py
│   ├── main.py
│   ├── models.py
│   ├── result_payload.py
│   ├── task_queue.py
│   ├── task_store.py
│   └── utils.py
├── services/
├── tasks/
├── static/
├── uploads/
├── docker-compose.yml
├── requirements.txt
└── README.md
```

## Ограничения

- Очередь in-process: при рестарте теряется
- Большие файлы читаются в память целиком
- Diarization значительно увеличивает нагрузку

## Лицензия

MIT
